<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Box2D.js Joints Demo</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        
        #container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        canvas {
            border: 2px solid #333;
            display: block;
            margin: 20px auto;
            background: #87CEEB;
            cursor: crosshair;
        }
        
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button.active {
            background: #2196F3;
        }
        
        #info {
            text-align: center;
            color: #666;
            margin-top: 20px;
        }
        
        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
            font-size: 14px;
            color: #666;
        }
        
        .demo-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .demo-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>Box2D.js Joints & Advanced Features Demo</h1>
        <p>This demo showcases joints, additional shapes, ray casting, and advanced body features.</p>
        
        <canvas id="canvas" width="700" height="500"></canvas>
        
        <div class="controls">
            <button onclick="createDistanceJoint()">Distance Joint</button>
            <button onclick="createRevoluteJoint()">Revolute Joint</button>
            <button onclick="createPrismaticJoint()">Prismatic Joint</button>
            <button onclick="createWeldJoint()">Weld Joint</button>
            <button onclick="createCapsule()">Add Capsule</button>
            <button onclick="createPolygon()">Add Pentagon</button>
            <button onclick="testRayCasting()">Ray Cast Test</button>
            <button onclick="reset()">Reset</button>
        </div>
        
        <div class="stats">
            <div>Bodies: <span id="bodyCount">0</span></div>
            <div>Joints: <span id="jointCount">0</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
        
        <div class="demo-section">
            <div class="demo-title">Enhanced Features:</div>
            <div>✓ Multiple joint types (Distance, Revolute, Prismatic, Weld)</div>
            <div>✓ Additional shapes (Capsules, Polygons, Segments)</div>
            <div>✓ Ray casting with collision detection</div>
            <div>✓ Advanced body properties (mass, inertia, sleep state)</div>
        </div>
        
        <div id="info">
            Loading Box2D...
        </div>
    </div>

    <script src="./box2d_bindings.js"></script>
    <script>
        // We need to use the script approach instead of ES6 modules for Emscripten UMD output
        let box2d;
        let world;
        let bodies = [];
        let joints = [];
        let canvas, ctx;
        let lastTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        
        // Canvas setup
        canvas = document.getElementById('canvas');
        ctx = canvas.getContext('2d');
        
        // Physics constants
        const SCALE = 30; // pixels per meter
        const WORLD_WIDTH = canvas.width / SCALE;
        const WORLD_HEIGHT = canvas.height / SCALE;
        
        // Track object shapes for rendering
        const objectShapes = new Map(); // bodyId -> {type, size, color}
        const rayResults = []; // For visualizing ray casts
        
        // Initialize Box2D
        async function init() {
            try {
                // Box2D is a global function that returns a promise
                box2d = await Box2D();
                console.log('Box2D loaded successfully!');
                
                // Create world with gravity
                world = new box2d.World(0, 10); // gravity pointing down
                
                // Create boundaries
                createBoundaries();
                
                // Create some initial demonstration objects
                createInitialDemo();
                
                document.getElementById('info').textContent = 'Box2D loaded! Try the buttons above to see joints and advanced features.';
                
                // Start the simulation loop
                gameLoop();
                
            } catch (error) {
                console.error('Failed to load Box2D:', error);
                document.getElementById('info').textContent = 'Failed to load Box2D: ' + error.message;
            }
        }
        
        function createBoundaries() {
            // Create ground
            const ground = new box2d.Body(world, WORLD_WIDTH/2, WORLD_HEIGHT - 0.5, box2d.BodyType.staticBody);
            box2d.ShapeFactory.createBox(ground, WORLD_WIDTH/2, 0.5, 0.0, 0.0);
            
            // Create left wall
            const leftWall = new box2d.Body(world, 0.5, WORLD_HEIGHT/2, box2d.BodyType.staticBody);
            box2d.ShapeFactory.createBox(leftWall, 0.5, WORLD_HEIGHT/2, 0.0, 0.0);
            
            // Create right wall
            const rightWall = new box2d.Body(world, WORLD_WIDTH - 0.5, WORLD_HEIGHT/2, box2d.BodyType.staticBody);
            box2d.ShapeFactory.createBox(rightWall, 0.5, WORLD_HEIGHT/2, 0.0, 0.0);
            
            bodies.push(ground, leftWall, rightWall);
            
            // Mark these as static bodies for rendering
            objectShapes.set(ground, {type: 'box', size: {w: WORLD_WIDTH, h: 1}, color: '#8B4513'});
            objectShapes.set(leftWall, {type: 'box', size: {w: 1, h: WORLD_HEIGHT}, color: '#8B4513'});
            objectShapes.set(rightWall, {type: 'box', size: {w: 1, h: WORLD_HEIGHT}, color: '#8B4513'});
        }
        
        function createInitialDemo() {
            // Create a simple pendulum to show revolute joint
            const anchor = new box2d.Body(world, 10, 3, box2d.BodyType.staticBody);
            box2d.ShapeFactory.createCircle(anchor, 0.2, 0.0, 0.3);
            bodies.push(anchor);
            objectShapes.set(anchor, {type: 'circle', size: {r: 0.2}, color: '#666'});
            
            const pendulum = new box2d.Body(world, 10, 6, box2d.BodyType.dynamicBody);
            box2d.ShapeFactory.createBox(pendulum, 0.3, 1.5, 1.0, 0.3);
            bodies.push(pendulum);
            objectShapes.set(pendulum, {type: 'box', size: {w: 0.6, h: 3}, color: '#FF6B6B'});
            
            // Create revolute joint
            const joint = new box2d.RevoluteJoint(world, anchor, pendulum, 0, 0);
            joints.push(joint);
        }
        
        // Joint creation functions
        function createDistanceJoint() {
            // Create two bodies connected by a distance joint
            const bodyA = new box2d.Body(world, 5, 2, box2d.BodyType.dynamicBody);
            box2d.ShapeFactory.createCircle(bodyA, 0.5, 1.0, 0.3);
            bodies.push(bodyA);
            objectShapes.set(bodyA, {type: 'circle', size: {r: 0.5}, color: '#4ECDC4'});
            
            const bodyB = new box2d.Body(world, 8, 2, box2d.BodyType.dynamicBody);
            box2d.ShapeFactory.createCircle(bodyB, 0.5, 1.0, 0.3);
            bodies.push(bodyB);
            objectShapes.set(bodyB, {type: 'circle', size: {r: 0.5}, color: '#96CEB4'});
            
            // Create distance joint
            const joint = new box2d.DistanceJoint(world, bodyA, bodyB, 0, 0, 0, 0);
            joints.push(joint);
        }
        
        function createRevoluteJoint() {
            // Create a simple hinge
            const base = new box2d.Body(world, 15, 8, box2d.BodyType.staticBody);
            box2d.ShapeFactory.createBox(base, 0.3, 0.3, 0.0, 0.3);
            bodies.push(base);
            objectShapes.set(base, {type: 'box', size: {w: 0.6, h: 0.6}, color: '#666'});
            
            const arm = new box2d.Body(world, 17, 8, box2d.BodyType.dynamicBody);
            box2d.ShapeFactory.createBox(arm, 1.0, 0.2, 1.0, 0.3);
            bodies.push(arm);
            objectShapes.set(arm, {type: 'box', size: {w: 2.0, h: 0.4}, color: '#FFEAA7'});
            
            const joint = new box2d.RevoluteJoint(world, base, arm, 0, 0);
            joints.push(joint);
        }
        
        function createPrismaticJoint() {
            // Create a sliding mechanism
            const guide = new box2d.Body(world, 3, 12, box2d.BodyType.staticBody);
            box2d.ShapeFactory.createBox(guide, 2.0, 0.2, 0.0, 0.3);
            bodies.push(guide);
            objectShapes.set(guide, {type: 'box', size: {w: 4.0, h: 0.4}, color: '#666'});
            
            const slider = new box2d.Body(world, 3, 11, box2d.BodyType.dynamicBody);
            box2d.ShapeFactory.createBox(slider, 0.4, 0.4, 1.0, 0.3);
            bodies.push(slider);
            objectShapes.set(slider, {type: 'box', size: {w: 0.8, h: 0.8}, color: '#DDA0DD'});
            
            const joint = new box2d.PrismaticJoint(world, guide, slider, 0, 0, 1, 0);
            joints.push(joint);
        }
        
        function createWeldJoint() {
            // Create a rigid connection
            const bodyA = new box2d.Body(world, 20, 5, box2d.BodyType.dynamicBody);
            box2d.ShapeFactory.createBox(bodyA, 0.5, 0.5, 1.0, 0.3);
            bodies.push(bodyA);
            objectShapes.set(bodyA, {type: 'box', size: {w: 1.0, h: 1.0}, color: '#FF6B6B'});
            
            const bodyB = new box2d.Body(world, 21, 5, box2d.BodyType.dynamicBody);
            box2d.ShapeFactory.createBox(bodyB, 0.5, 0.5, 1.0, 0.3);
            bodies.push(bodyB);
            objectShapes.set(bodyB, {type: 'box', size: {w: 1.0, h: 1.0}, color: '#4ECDC4'});
            
            const joint = new box2d.WeldJoint(world, bodyA, bodyB, 0, 0);
            joints.push(joint);
        }
        
        function createCapsule() {
            const body = new box2d.Body(world, Math.random() * 10 + 5, 1, box2d.BodyType.dynamicBody);
            box2d.ShapeFactory.createCapsule(body, 1.5, 0.3, 1.0, 0.3);
            bodies.push(body);
            objectShapes.set(body, {type: 'capsule', size: {h: 1.5, r: 0.3}, color: '#45B7D1'});
        }
        
        function createPolygon() {
            const body = new box2d.Body(world, Math.random() * 10 + 5, 1, box2d.BodyType.dynamicBody);
            
            // Create a pentagon
            const points = [];
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * 2 * Math.PI;
                points.push({
                    x: Math.cos(angle) * 0.7,
                    y: Math.sin(angle) * 0.7
                });
            }
            
            box2d.ShapeFactory.createPolygon(body, points, 1.0, 0.3);
            bodies.push(body);
            objectShapes.set(body, {type: 'polygon', size: {points: points}, color: '#96CEB4'});
        }
        
        function testRayCasting() {
            // Cast a ray from left to right
            const originX = 1;
            const originY = 8;
            const directionX = 20;
            const directionY = 0;
            
            const result = world.castRayClosest(originX, originY, directionX, directionY);
            
            // Store result for visualization
            rayResults.push({
                origin: {x: originX, y: originY},
                direction: {x: directionX, y: directionY},
                result: result,
                time: Date.now()
            });
            
            // Remove old rays
            const now = Date.now();
            for (let i = rayResults.length - 1; i >= 0; i--) {
                if (now - rayResults[i].time > 3000) { // 3 seconds
                    rayResults.splice(i, 1);
                }
            }
            
            console.log('Ray cast result:', result);
        }
        
        // Reset the simulation
        window.reset = function() {
            if (!world) return;
            
            // Clear dynamic bodies and joints
            bodies = bodies.filter(body => {
                const pos = body.getPosition();
                const isStatic = pos.y > WORLD_HEIGHT - 1 || pos.x < 1 || pos.x > WORLD_WIDTH - 1;
                if (!isStatic) {
                    objectShapes.delete(body);
                }
                return isStatic;
            });
            
            joints = []; // Clear joints
            rayResults.length = 0; // Clear ray results
            
            // Recreate initial demo
            createInitialDemo();
        }
        
        // Game loop
        function gameLoop(currentTime = 0) {
            if (!world) return;
            
            // Calculate FPS
            frameCount++;
            if (currentTime - lastFpsUpdate > 1000) {
                document.getElementById('fps').textContent = Math.round((frameCount * 1000) / (currentTime - lastFpsUpdate));
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }
            
            // Step the physics simulation
            world.step(1/60, 4);
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Filter out invalid bodies and update count
            bodies = bodies.filter(body => body.isValid());
            joints = joints.filter(joint => joint.isValid());
            
            document.getElementById('bodyCount').textContent = bodies.length;
            document.getElementById('jointCount').textContent = joints.length;
            
            // Draw all bodies
            bodies.forEach(body => {
                if (!body.isValid()) return;
                
                const pos = body.getPosition();
                const angle = body.getAngle();
                const shape = objectShapes.get(body);
                
                if (!shape) return;
                
                ctx.save();
                ctx.translate(pos.x * SCALE, pos.y * SCALE);
                ctx.rotate(angle);
                
                ctx.fillStyle = shape.color;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                
                if (shape.type === 'box') {
                    const halfW = (shape.size.w * SCALE) / 2;
                    const halfH = (shape.size.h * SCALE) / 2;
                    ctx.fillRect(-halfW, -halfH, halfW * 2, halfH * 2);
                    ctx.strokeRect(-halfW, -halfH, halfW * 2, halfH * 2);
                } else if (shape.type === 'circle') {
                    const radius = shape.size.r * SCALE;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw a line to show rotation
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(radius * 0.8, 0);
                    ctx.stroke();
                } else if (shape.type === 'capsule') {
                    const height = shape.size.h * SCALE;
                    const radius = shape.size.r * SCALE;
                    
                    // Draw capsule as rectangle with rounded ends
                    ctx.fillRect(-radius, -height/2, radius * 2, height);
                    ctx.strokeRect(-radius, -height/2, radius * 2, height);
                    
                    // Draw rounded ends
                    ctx.beginPath();
                    ctx.arc(0, -height/2, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(0, height/2, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else if (shape.type === 'polygon') {
                    ctx.beginPath();
                    const points = shape.size.points;
                    ctx.moveTo(points[0].x * SCALE, points[0].y * SCALE);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x * SCALE, points[i].y * SCALE);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                
                ctx.restore();
            });
            
            // Draw ray casting results
            rayResults.forEach(ray => {
                const alpha = Math.max(0, 1 - (Date.now() - ray.time) / 3000);
                ctx.globalAlpha = alpha;
                
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(ray.origin.x * SCALE, ray.origin.y * SCALE);
                
                if (ray.result.hit) {
                    ctx.lineTo(ray.result.point.x * SCALE, ray.result.point.y * SCALE);
                    ctx.stroke();
                    
                    // Draw hit point
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(ray.result.point.x * SCALE, ray.result.point.y * SCALE, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw normal
                    ctx.strokeStyle = '#00FF00';
                    ctx.beginPath();
                    ctx.moveTo(ray.result.point.x * SCALE, ray.result.point.y * SCALE);
                    ctx.lineTo(
                        (ray.result.point.x + ray.result.normal.x * 2) * SCALE,
                        (ray.result.point.y + ray.result.normal.y * 2) * SCALE
                    );
                    ctx.stroke();
                } else {
                    ctx.lineTo((ray.origin.x + ray.direction.x) * SCALE, (ray.origin.y + ray.direction.y) * SCALE);
                    ctx.stroke();
                }
                
                ctx.globalAlpha = 1;
            });
            
            requestAnimationFrame(gameLoop);
        }
        
        // Start initialization
        init();
    </script>
</body>
</html>