<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Box2D.js Demo</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        
        #container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        canvas {
            border: 2px solid #333;
            display: block;
            margin: 20px auto;
            background: #87CEEB;
            cursor: crosshair;
        }
        
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button.active {
            background: #2196F3;
        }
        
        #info {
            text-align: center;
            color: #666;
            margin-top: 20px;
        }
        
        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>Box2D.js Physics Demo</h1>
        <p>This demo shows Box2D physics running in the browser via WebAssembly. Click on the canvas to add objects!</p>
        
        <canvas id="canvas" width="600" height="400"></canvas>
        
        <div class="controls">
            <button id="boxMode" onclick="setMode('box')" class="active">Box Mode</button>
            <button id="circleMode" onclick="setMode('circle')">Circle Mode</button>
            <button onclick="reset()">Reset</button>
        </div>
        
        <div class="stats">
            <div>Bodies: <span id="bodyCount">0</span></div>
            <div>FPS: <span id="fps">0</span></div>
        </div>
        
        <div id="info">
            Loading Box2D...
        </div>
    </div>

    <script src="./box2d_bindings.js"></script>
    <script>
        // We need to use the script approach instead of ES6 modules for Emscripten UMD output
        let box2d;
        let world;
        let bodies = [];
        let canvas, ctx;
        let currentMode = 'box';
        let lastTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        
        // Canvas setup
        canvas = document.getElementById('canvas');
        ctx = canvas.getContext('2d');
        
        // Physics constants
        const SCALE = 30; // pixels per meter
        const WORLD_WIDTH = canvas.width / SCALE;
        const WORLD_HEIGHT = canvas.height / SCALE;
        
        // Track object shapes for rendering
        const objectShapes = new Map(); // bodyId -> {type, size, color}
        
        // Initialize Box2D
        async function init() {
            try {
                // Box2D is a global function that returns a promise
                box2d = await Box2D();
                console.log('Box2D loaded successfully!');
                
                // Create world with gravity
                world = new box2d.World(0, 10); // gravity pointing down
                
                // Create boundaries
                createBoundaries();
                
                document.getElementById('info').textContent = 'Box2D loaded! Click on the canvas to add objects.';
                
                // Add canvas click handler
                canvas.addEventListener('click', handleCanvasClick);
                
                // Start the simulation loop
                gameLoop();
                
            } catch (error) {
                console.error('Failed to load Box2D:', error);
                document.getElementById('info').textContent = 'Failed to load Box2D: ' + error.message;
            }
        }
        
        function createBoundaries() {
            // Create ground
            const ground = new box2d.Body(world, WORLD_WIDTH/2, WORLD_HEIGHT - 0.5, box2d.BodyType.staticBody);
            box2d.ShapeFactory.createBox(ground, WORLD_WIDTH/2, 0.5, 0.0, 0.0);
            
            // Create left wall
            const leftWall = new box2d.Body(world, 0.5, WORLD_HEIGHT/2, box2d.BodyType.staticBody);
            box2d.ShapeFactory.createBox(leftWall, 0.5, WORLD_HEIGHT/2, 0.0, 0.0);
            
            // Create right wall
            const rightWall = new box2d.Body(world, WORLD_WIDTH - 0.5, WORLD_HEIGHT/2, box2d.BodyType.staticBody);
            box2d.ShapeFactory.createBox(rightWall, 0.5, WORLD_HEIGHT/2, 0.0, 0.0);
            
            bodies.push(ground, leftWall, rightWall);
            
            // Mark these as static bodies for rendering
            objectShapes.set(ground, {type: 'box', size: {w: WORLD_WIDTH, h: 1}, color: '#8B4513'});
            objectShapes.set(leftWall, {type: 'box', size: {w: 1, h: WORLD_HEIGHT}, color: '#8B4513'});
            objectShapes.set(rightWall, {type: 'box', size: {w: 1, h: WORLD_HEIGHT}, color: '#8B4513'});
        }
        
        function handleCanvasClick(event) {
            if (!world) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / SCALE);
            const y = ((event.clientY - rect.top) / SCALE);
            
            if (currentMode === 'box') {
                addBox(x, y);
            } else if (currentMode === 'circle') {
                addCircle(x, y);
            }
        }
        
        // Add a falling box at position
        function addBox(x = null, y = null) {
            if (!world) return;
            
            if (x === null) x = Math.random() * (WORLD_WIDTH - 2) + 1;
            if (y === null) y = 1;
            
            const body = new box2d.Body(world, x, y, box2d.BodyType.dynamicBody);
            const size = 0.3 + Math.random() * 0.5;
            box2d.ShapeFactory.createBox(body, size, size, 1.0, 0.3);
            bodies.push(body);
            
            // Store shape info for rendering
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD'];
            objectShapes.set(body, {
                type: 'box', 
                size: {w: size * 2, h: size * 2}, 
                color: colors[Math.floor(Math.random() * colors.length)]
            });
        }
        
        // Add a falling circle at position
        function addCircle(x = null, y = null) {
            if (!world) return;
            
            if (x === null) x = Math.random() * (WORLD_WIDTH - 2) + 1;
            if (y === null) y = 1;
            
            const body = new box2d.Body(world, x, y, box2d.BodyType.dynamicBody);
            const radius = 0.2 + Math.random() * 0.4;
            box2d.ShapeFactory.createCircle(body, radius, 1.0, 0.3);
            bodies.push(body);
            
            // Store shape info for rendering
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD'];
            objectShapes.set(body, {
                type: 'circle', 
                size: {r: radius}, 
                color: colors[Math.floor(Math.random() * colors.length)]
            });
        }
        
        // Reset the simulation
        window.reset = function() {
            if (!world) return;
            
            // Clear dynamic bodies from both arrays and shape map
            bodies = bodies.filter(body => {
                const pos = body.getPosition();
                const isStatic = pos.y > WORLD_HEIGHT - 1 || pos.x < 1 || pos.x > WORLD_WIDTH - 1;
                if (!isStatic) {
                    objectShapes.delete(body);
                }
                return isStatic;
            });
        }
        
        // Set interaction mode
        window.setMode = function(mode) {
            currentMode = mode;
            document.getElementById('boxMode').classList.toggle('active', mode === 'box');
            document.getElementById('circleMode').classList.toggle('active', mode === 'circle');
        }
        
        // Game loop
        function gameLoop(currentTime = 0) {
            if (!world) return;
            
            // Calculate FPS
            frameCount++;
            if (currentTime - lastFpsUpdate > 1000) {
                document.getElementById('fps').textContent = Math.round((frameCount * 1000) / (currentTime - lastFpsUpdate));
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }
            
            // Step the physics simulation
            world.step(1/60, 4);
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Filter out invalid bodies and update count
            bodies = bodies.filter(body => body.isValid());
            document.getElementById('bodyCount').textContent = bodies.length;
            
            // Draw all bodies
            bodies.forEach(body => {
                if (!body.isValid()) return;
                
                const pos = body.getPosition();
                const angle = body.getAngle();
                const shape = objectShapes.get(body);
                
                if (!shape) return;
                
                ctx.save();
                ctx.translate(pos.x * SCALE, pos.y * SCALE);
                ctx.rotate(angle);
                
                ctx.fillStyle = shape.color;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                
                if (shape.type === 'box') {
                    const halfW = (shape.size.w * SCALE) / 2;
                    const halfH = (shape.size.h * SCALE) / 2;
                    ctx.fillRect(-halfW, -halfH, halfW * 2, halfH * 2);
                    ctx.strokeRect(-halfW, -halfH, halfW * 2, halfH * 2);
                } else if (shape.type === 'circle') {
                    const radius = shape.size.r * SCALE;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw a line to show rotation
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(radius * 0.8, 0);
                    ctx.stroke();
                }
                
                ctx.restore();
            });
            
            requestAnimationFrame(gameLoop);
        }
        
        // Start initialization
        init();
    </script>
</body>
</html>